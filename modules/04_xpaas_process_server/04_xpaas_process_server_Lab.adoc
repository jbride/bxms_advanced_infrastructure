:scrollbar:
:data-uri:
:toc2:

= xPaaS Process Server Lab

*Goals*

In this lab we will explore the Red Hat xPaaS Process Server. The Process Server runtime is a BPMS KIE Server configured for deployment on OpenShift. The Process Server supports source-to-image builds, as well as binary deployments starting from pre-built kjars.

The lab consists of three parts:

* exploring the source-to-image (S2I) functionality of the OpenShift xPaaS Process Server.
* example of binary deployment with the OpenShift xPaaS Process Server. This scenario also leverages side-by-side deployment of different versions of the same kjar, using aliases to make this transparent to application clients.
* example of integration of the Process Server with Red Hat SSO.

== Prerequisites and setup

In order to do this lab you will need

* access to a project on a Openshift V3 (OSE) hosted environment.
* required tools on your local workstation: OpenShift CLI client (`oc`), git, maven, curl. +
The lab virtual machine used in this course has these tools installed.
* access to Github to clone the projects used in this lab.

Before starting the lab, log into the OpenShift environment using the OpenShift CLI tool. If using a hosted environment, use the credentials provided to you:

----
$ oc login <URL to OpenShift V3 environment>
----

On the environment provided to you, a project has been created. After logging in, all CLI commands will target this project.

Also, make sure you can access the OpenShift Web Console. Open a browser, and navigate to the OpenShift V3 URL. Login using the same credentials as used for the CLI.

Some tasks in this lab are identical to the xPaaS Decision Server Lab, for example setting up the Git and Nexus repositories. Detailed instructions for these parts will not be repeated here. Please refer to the xPaaS Decision Server Lab instructions if needed.

:numbered:

== xPaaS Process Server Lab 1 : S2I deployment

=== Gogs Git Server

If you did the xPaaS Decision Server Lab, the Gogs server should be up and running. If not, refer to the xPaaS Decision Server Lab for detailed instructions to install the Gogs server on OpenShift.

. Log in into the Gogs server with your username/password combination.
. Create an organization called `process-server-s2i`. +
Make sure that you are a member of the new organization. You should be listed as `owner`.
. Create a repository in the `process-server-s2i` organization the with name `policyquote`. Make sure the repository is not private. Make sure the checkbox `Initialize this repository with selected file and template` is unchecked. Click `Create repository`. +
Later in the lab we will push our BPMS project to this repository.

=== Nexus Maven Repository Server

If you did the xPaaS Decision Server Lab, the Nexus server should be up and running. If not, refer to the xPaaS Decision Server Lab for detailed instructions to install the Nexus server on OpenShift.

=== Process Server Image Stream and S2I Template

The image stream for the Process Server image will be reused by different templates in this lab.

. In the virtual machine, open a terminal, and change to the directory in the cloned lab project that contains the templates for the Process Server lab.
+
----
$ cd /home/jboss/lab/bxms-advanced-infrastructure-lab/xpaas/process-server
----
. Review the `processserver-63-is.yaml` definition file. This file defines the ImageStream for the Process Server 6.3 image, hosted in the Red Hat docker registry. The latest version of this image is 1.3.
. Create the ImageStream for the Process Server image:
+
----
$ oc create -f processserver-63-is.yaml
----

The Process Server requires a database. For this lab we will use MySQL, with the MySql data directory attached to persistent storage.

. Review the `processserver-mysql-persistent-s2i.yaml` template. +
This template defines:
* A BuildConfig for the S2I build. +
The BuildConfig defines a source build, pointing to a git repo, as well as the builder image, through the ImageStream we defined earlier. +
The build will be triggered through a webhook (triggered whenever we push new code to the git repository), or by a change in the builder image.
* An ImageStream for the image created as a result of the build.
* A DeploymentConfig for the pod(s) running the image created as result of the build. The number of replica's is set to one.
* A Service for the Process Server.
* A Route for the Process Server.
* A DeploymentConfig for the MySQL database pod. The source image is the MySQL Docker image shipped as part of OpenShift. The MySQL data directory is mounted as a volume.
* A PersistentVolumeClaim for the MySQL data volume.
* A Service for the MySQL database, to expose the MySQL database to the Process Engine pods.
* Parameters:
** APPLICATION_NAME : the name for the application.
** KIE_CONTAINER_DEPLOYMENT : describes what kjar(s) needs to be deployed on the Decision Server, in the format `containerId=groupId:artifactId:version|c2=g2:a2:v2`
** KIE_CONTAINER_REDIRECT_ENABLED : Enable redirect functionality for KIE containers. Defaults to true. Should be true when different versions of the same kjar are to be deployed side-by-side.
** KIE_SERVER_USER : the user name to access the KIE Server REST or JMS interface. Defaults to `kieserver`.
** KIE_SERVER_PASSWORD : The password to access the KIE Server REST or JMS interface. Defaults to a generated value.
** KIE_SERVER_BYPASS_AUTH_USER : Whether to bypass the authenticated user. This allows to use a system user account to perform task operations on behalf of the real user. Defaults to false.
** KIE_SERVER_HT_CALLBACK : Callback implementation to resolve users and groups. Defaults to `jaas`.
** KIE_SERVER_PERSISTENCE_DIALECT : Hibernate persistence dialect. Defaults to `org.hibernate.dialect.MySQL5Dialect`.
** DB_USERNAME : Database user name. Defaults to a generated value.
** DB_PASSWORD : Database user password. Defaults to a generated value.
** DB_JNDI : JNDI name of the datasource. Defaults to `java:jboss/datasources/ExampleDS`.
** DB_DATABASE : Database schema name. Defaults to `bpms`.
** MYSQL_LOWER_CASE_TABLE_NAMES : Sets how the table names are stored and compared. Defaults to `1` (true).
** HOSTNAME_HTTP : Custom hostname for the http service route. Leave blank for default hostname generated by OpenShift.
** SOURCE_REPOSITORY_URL : Git source URI for application. Required.
** SOURCE_REPOSITORY_REF : the Git branch/tag reference to build. Defaults to `master`.
** CONTEXT_DIR : The path within the Git project to build. Leave blank for the root project directory.
** GITHUB_WEBHOOK_SECRET : GitHub trigger secret. Will be added to the webhook URL. Defaults to a generated value.
** GENERIC_WEBHOOK_SECRET : Generic build trigger secret. Will be added to the webhook URL. Defaults to a generated value.
** IMAGE_STREAM_NAMESPACE : Namespace in which the ImageStreams for Red Hat xPaaS images are installed. These ImageStreams are normally installed in the openshift namespace. You should only need to modify this if you've installed the ImageStreams in a different namespace/project (which is the case in our lab).
** MAVEN_MIRROR_URL : The URL of the maven mirror (Nexus server)
** VOLUME_CAPACITY : the volume capacity for the PersistentVolumeClaim for the database, defaults to 512 Mi.
* Note: The Process Server uses an insecure route (http, no https).
. Import the template into your OpenShift project:
+
----
$ oc create -f processserver-mysql-persistent-s2i.yaml
----

=== Policyquote-process sample application

The Policyquote-process sample application is a very simple BPMS application, consisting of a single process model and a data model with a Driver and a Policy object. A process is started with an instance of these objects as process variables. The process consists of a User task assigned to the group `agent`, and potentially a review task assigned to the group `reviewer` if the price set by the `agent` user is more than 500.

image::images/policyquote-process.png[]

The application has been developed in Business-Central, and can be imported into Business-Central if you want to review, extend or modify it.

In this part of the lab, we will clone the Policyquote-process project from Github, and push it to the Gogs server on OpenShift to act as source for the S2I build.

. In the virtual machine, open a terminal and change to the lab home folder.
+
----
$ cd /home/jboss/lab
----
. Clone the Policyquote-process project from the GPTE Github site:
+
----
$ git clone https://github.com/gpe-mw-training/bxms-xpaas-policyquote-process
----
. Add a remote repository to the cloned project pointing to our Gogs git server:
+
----
$ cd bxms-xpaas-policyquote-process
$ git remote add gogs http://<gogs username>:<gogs password>@<url of the gogs route>/process-server-s2i/policyquote.git
----
+
Replace `<gogs password>`,`<url of the gogs route>` and `<gogs username>` with the appropriate values for your environment.
. Push the code to the Gogs server:
+
----
$ git push gogs master
----
. We need to define users and roles for our application. By default the Process Server uses properties files to define users and roles, and we are going to use the same mechanism for our lab. +
The Process Server image comes with empty properties files for application users and roles, so we need to add them as part of the S2I build. This can be done by adding the properties files to a folder called `configuration` in the build root folder of our project. As part of the S2I build, the contents of the `configuration` folder is copied to the `$JBOSS_HOME/standalone/configuration` folder on the image. The user defined in the template (`KIE_SERVER_USER/KIE_SERVER_PASSWORD`) will also be added to the properties files during the S2I build.
.. Change to the `policyquote-process` directory of the cloned Policyquote-process project. This is the directory that contains the POM file for the application.
+
----
$ cd policyquote-process
----
.. Create a directory called `configuration`, and create two files, called `application-users.properties` and `application-roles.properties`.
+
----
$ mkdir configuration
$ touch configuration/application-users.properties
$ touch configuration/application-roles.properties
----
.. Using a text editor, open the `configuration/application-users.properties` file. Paste the following contents in the file and save:
+
----
user1=e6e3515c498a9dd0d3f9ff109a563d70
user10=aab70ed7128574f33830762d5a7706b8
user11=d52988665526b974adda93cbd3af9657
user2=60a186310ff25f5eaf61371df513e9dd
user20=63b620eaa18caf1df6a29891a24f5338
user21=37e033fbd7f1398e9897b7bba355338b
----
+
All users have the password `user`.
.. Open the `configuration/application-roles.properties` file. Paste the following contents in the file and save:
+
----
user1=kie-server,agent
user10=kie-server,agent
user11=kie-server,agent
user2=kie-server,reviewer
user21=kie-server,reviewer
user22=kie-server,reviewer
----
+
Note that all users require the `kie-server` role in order to be able to use the REST API of the Process Server.
.. Add to git, commit and push to Gogs
+
----
$ git add configuration/application-users.properties
$ git add configuration/application-roles.properties
$ git commit -m "users and roles for the application"
$ git push gogs master
----

=== OpenShift Process Server Application

. In the virtual machine, open a terminal, change to the directory in the cloned lab project that contains the templates for the Process Server lab:
+
----
$ cd /home/jboss/lab/bxms-advanced-infrastructure-lab/xpaas/process-server
----
. Issue the following commands (replace expressions between `<>` with correct values for your environment) to create the application:
+
----
$ application_name=policyquote
$ source_repo=http://gogs:3000/process-server-s2i/policyquote.git
$ context_dir=policyquote-process
$ nexus_url=http://nexus:8081
$ kieserver_password=kieserver1!
$ is_namespace=<name of your OpenShift project>
$ kie_container_deployment="policyquote-process=com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT"
$ oc new-app --template=processserver63-mysql-persistent-s2i -p APPLICATION_NAME=$application_name,SOURCE_REPOSITORY_URL=$source_repo,CONTEXT_DIR=$context_dir,KIE_SERVER_PASSWORD=$kieserver_password,IMAGE_STREAM_NAMESPACE=$is_namespace,KIE_CONTAINER_DEPLOYMENT=$kie_container_deployment,KIE_CONTAINER_REDIRECT_ENABLED=false,MAVEN_MIRROR_URL=$nexus_url/content/groups/public/
----
+
* Note that the KIE_CONTAINER_REDIRECT_ENABLED environment variable is set to false. This means that the name of the KIE-Container for our application will be `policyquote-process`, as defined in KIE_CONTAINER_DEPLOYMENT. +
Also note that we need to specify the context directory for the build, which corresponds to the directory containing the POM file. This will be the base directory for the S2I build.

. Check the progress of the build and deployment of the application in the OpenShift console.
* If you finished the Decision Server Lab, the build will be fairly fast, as the Nexus maven proxy is already seeded with the build dependencies. Actually most of the build time is spent pushing the built Docker image to the internal registry.
* The S2I build is happening in a builder pod, named `policyquote-1-build`. Check the logs for this pod in the web console, or use the Openshift CLI:
+
----
$ oc logs -f policyquote-1-build
----
* At the end of the build cycle, you should see the following in the builder pod log:
+
----
E1028 12:48:05.162259       1 util.go:91] INFO: KieModule was added: ZipKieModule[releaseId=com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT,file=/home/jboss/.m2/repository/com/redhat/gpte/xpaas/process-server/policyquote-process/1.0-SNAPSHOT/policyquote-process-1.0-SNAPSHOT.jar]
E1028 12:48:05.449644       1 util.go:91] Oct 28, 2016 12:48:05 PM org.openshift.kieserver.common.server.ContainerVerifier main
E1028 12:48:05.449660       1 util.go:91] INFO: com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT verified.
I1028 12:48:10.711522       1 sti.go:268] Using provided push secret for pushing 172.30.22.135:5000/xpaas/policyquote:latest image
I1028 12:48:10.712003       1 sti.go:272] Pushing 172.30.22.135:5000/xpaas/policyquote:latest image ...
I1028 12:49:46.470266       1 sti.go:288] Successfully pushed 172.30.22.135:5000/xpaas/policyquote:latest
----
* The image built by the builder pod is pushed to the OpenShift internal registry. This will trigger the deployment of the image.
* To check the logs of the application pod, locate the pod (name `policyquote-1-xxxxx`), and check the logs in the OpenShift console or with the CLI.
+
----
$ oc logs -f policyquote-1-xxxxx
----
* After some time, you will see something like:
+
----
12:50:36,611 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015874: JBoss EAP 6.4.11.GA (AS 7.5.11.Final-redhat-1) started in 27356ms - Started 391 of 483 services (132 services are lazy, passive or on-demand)
12:50:39,462 INFO  [org.drools.compiler.kie.builder.impl.KieRepositoryImpl] (EJB default - 1) KieModule was added: ZipKieModule[releaseId=com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT,file=/home/jboss/.m2/repository/com/redhat/gpte/xpaas/process-server/policyquote-process/1.0-SNAPSHOT/policyquote-process-1.0-SNAPSHOT.jar]
12:50:40,157 INFO  [org.quartz.core.SchedulerSignalerImpl] (EJB default - 1) Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl
12:50:40,158 INFO  [org.quartz.core.QuartzScheduler] (EJB default - 1) Quartz Scheduler v.1.8.5 created.
12:50:40,159 INFO  [org.quartz.impl.jdbcjobstore.JobStoreCMT] (EJB default - 1) Using db table-based data access locking (synchronization).
12:50:40,161 INFO  [org.quartz.impl.jdbcjobstore.JobStoreCMT] (EJB default - 1) JobStoreCMT initialized.
12:50:40,162 INFO  [org.quartz.core.QuartzScheduler] (EJB default - 1) Scheduler meta-data: Quartz Scheduler (v1.8.5) 'jBPMClusteredScheduler' with instanceId 'policyquote-1-21js61477673440134'
  Scheduler class: 'org.quartz.core.QuartzScheduler' - running locally.
  NOT STARTED.
  Currently in standby mode.
  Number of jobs executed: 0
  Using thread pool 'org.quartz.simpl.SimpleThreadPool' - with 5 threads.
  Using job-store 'org.quartz.impl.jdbcjobstore.JobStoreCMT' - which supports persistence. and is clustered.

12:50:40,163 INFO  [org.quartz.impl.StdSchedulerFactory] (EJB default - 1) Quartz scheduler 'jBPMClusteredScheduler' initialized from specified file: '/opt/eap/bin/quartz.properties'
12:50:40,163 INFO  [org.quartz.impl.StdSchedulerFactory] (EJB default - 1) Quartz scheduler version: 1.8.5
12:50:40,186 INFO  [org.kie.server.services.jbpm.JbpmKieServerExtension] (EJB default - 1) Container policyquote-process created successfully
12:50:40,189 INFO  [org.kie.server.services.impl.KieServerImpl] (EJB default - 1) Container policyquote-process (for release id com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT) successfully started
12:50:42,194 INFO  [org.quartz.core.QuartzScheduler] (Thread-93) Scheduler jBPMClusteredScheduler_$_policyquote-1-21js61477673440134 started.
----
* By that time, the service and the route will be started, and our Process Server application is ready to serve requests.
+
image::images/policyquote-process-application-ocp.png[]

=== Testing the sample application

We can test the application using `curl` and the REST API of the Process Server.

. In a terminal window, issue the following commands:
+
----
$ policyquote_app=<URL of the policyquote app route>
$ kieserver_password=kieserver1!
----
. To check the health of the Process Server:
+
----
$ curl -X GET -H "Accept: application/json" --user kieserver:$kieserver_password "$policyquote_app/kie-server/services/rest/server"
----
+
Response:
+
----
{
  "type": "SUCCESS",
  "msg": "Kie Server info",
  "result": {
    "kie-server-info": {
      "version": "6.4.0.Final-redhat-3",
      "name": "kieserver-policyquote-1-21js6",
      "location": "http://policyquote-1-21js6:8080/kie-server/services/rest/server",
      "capabilities": [
        "BRM",
        "BPM",
        "KieServer"
      ],
      "messages": [
        {
          "severity": "INFO",
          "timestamp": 1477673436299,
          "content": [
            "Server KieServerInfo{serverId='kieserver-policyquote-1-21js6', version='6.4.0.Final-redhat-3', location='http://policyquote-1-21js6:8080/kie-server/services/rest/server'}started successfully at Fri Oct 28 12:50:36 EDT 2016"
          ]
        }
      ],
      "id": "kieserver-policyquote-1-21js6"
    }
  }
}
----
+
Note that the server location returned by this call does correspond to the URL of the pod, which is not accessible from the outside world.
. To check which KIE-Containers are deployed on the server:
+
----
$ curl -X GET -H "Accept: application/json" --user kieserver:$kieserver_password "$policyquote_app/kie-server/services/rest/server/containers"
----
+
Response:
+
----
{
  "type": "SUCCESS",
  "msg": "List of created containers",
  "result": {
    "kie-containers": {
      "kie-container": [
        {
          "status": "STARTED",
          "messages": [
            {
              "severity": "INFO",
              "timestamp": 1477673440202,
              "content": [
                "Container policyquote-process successfully created with module com.redhat.gpte.xpaas.process-server:policyquote-process:1.0-SNAPSHOT."
              ]
            }
          ],
          "container-id": "policyquote-process",
          "release-id": {
            "version": "1.0-SNAPSHOT",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "resolved-release-id": {
            "version": "1.0-SNAPSHOT",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "config-items": []
        }
      ]
    }
  }
}
----
+
There is 1 KIE-Container deployed, named `policyquote-process`, which resolves to the maven GAV of our project. This corresponds to the value of the `KIE_CONTAINER_DEPLOYMENT` parameter we passed in when creating the application.
. To start a process, we need to send a correctly formatted payload representing a Driver and a Policy object instance marshalled to JSON. The `/xpaas/process-server` directory of the lab contains an example. Make sure you are in that directory, and execute:
+
----
$ curl -X POST -H "Accept: application/json" -H "Content-Type: application/json" --user kieserver:$kieserver_password -d @policyquote-start-process-payload.json "$policyquote_app/kie-server/services/rest/server/containers/policyquote-process/processes/policyquote.PolicyQuoteProcess/instances"
----
+
NOTE: `policyquote-process` is the name of the KIE-Container we target, `policyquote.PolicyQuoteProcess` is the id of the process in our app.
+
The response of this call is the process instance id of the process that was created.
. To check that we have a running process instance, we can issue the following REST call:
+
----
$ curl -X GET -H "Accept: application/json" --user kieserver:$kieserver_password "$policyquote_app/kie-server/services/rest/server/queries/containers/policyquote-process/process/instances"
----
+
You should have (at least) one running process instance.
. The process instance we started is waiting in a User task node, assigned to the `agent` group. User `user1` is a member of that group, so we can query for the tasks which have `user1` as potential owner:
+
----
$ curl -X GET -H "Accept: application/json" --user user1:user "$policyquote_app/kie-server/services/rest/server/queries/tasks/instances/pot-owners"
----
+
Response:
+
----
{
  "task-summary": [
    {
      "task-id": 1,
      "task-name": "Set Price",
      "task-subject": "",
      "task-description": "",
      "task-status": "Ready",
      "task-priority": 0,
      "task-is-skipable": true,
      "task-created-on": 1477679120000,
      "task-activation-time": 1477679120000,
      "task-proc-inst-id": 1,
      "task-proc-def-id": "policyquote.PolicyQuoteProcess",
      "task-container-id": "policyquote-process",
      "task-parent-id": -1
    }
  ]
}
----
. As `user1`, we can claim and start the task.
+
----
$ curl -X PUT -H "Accept: application/json" --user user1:user "$policyquote_app/kie-server/services/rest/server/containers/policyquote-process/tasks/1/states/claimed"
$ curl -X PUT -H "Accept: application/json" --user user1:user "$policyquote_app/kie-server/services/rest/server/containers/policyquote-process/tasks/1/states/started"
----
. Still as `user1`, the task can be completed. We specify the policy price as payload of this call, using the `task_price` task output variable.
+
----
$ curl -X PUT -H "Accept: application/json" --user user1:user -d '{ "task_price" : 300 }' "$policyquote_app/kie-server/services/rest/server/containers/policyquote-process/tasks/1/states/completed"
----
+
. The tasks definitions in our process, including the input and output data associations, can be obtained through the following REST call:
+
----
$ curl -X GET -H "Accept: application/json" --user kieserver:$kieserver_password "$policyquote_app/kie-server/services/rest/server/containers/policyquote-process/processes/definitions/policyquote.PolicyQuoteProcess/tasks/users"
----
. In the logs of the Process Server pod you should see the following line, indicating that the process instance has been completed:
+
----
10:35:41,115 INFO  [stdout] (http-172.17.0.7:8080-1) Driver 1234: Policy price after calculation and review = 300
----

=== Application lifecycle

Managing changes in a Process Server application is more complex than with Decision Server applications, because of the state involved with processes versus the stateless nature of business rules invocations.

With Decision Server applications, we can simply build new pods with the new version of the rules application and do a rolling upgrade of the existing application pods.

With Process Servers this is not possible. If there are still process instances in a wait state for the old version, chances are high that these will not execute correctly with a new process definition (depending of course on the nature of the changes introduced). +
In a development or test environment we could recreate a complete new application, including the database pods, as we are probably less interested in dangling process instances from previous versions. But in a production environment this is of course unacceptable.

In that case, we need to be able to retain the previous process deployments next to the new ones, at least as long as we have running process instances for these previous versions.

The Process Server xPaaS images provide a mechanism to achieve this, by using KIE-Container aliases and redirects. We will explore this mechanism in the second part of this lab.

Before proceeding with the second part of the lab, tear down the `policyquote` application:

----
$ oc delete all -l "application=policyquote"
$ oc delete pvc policyquote-mysql-pvc
----

== xPaaS Process Server Lab 2 : 'binary' S2I deployment with alias redirection

In the second part of the Process Server lab, we will use the binary variant of the S2I build. When deploying a new version of the application, the previous versions (KIE-Containers) will be retained. This allows exiting process instances to continue executing in their original container. New process instances will be started in the new container. This is transparent to the clients.

To demonstrate that the OpenShift and xPaas is not limited to DevOps (where every commit potentially results in a new production deployment), we will simulate a more traditional git release process. In our release model development is done on the master branch, and when ready to be released, master is merged to the release branch. Deployment is triggered from the release branch.

=== Gogs git server

If you did not finish the Decision Server Lab, please refer to the instructions in this lab to:

* create a Gogs user `jenkins`.
* create a repository for the lab project on Gogs.

{empty} +

. Create organizations, users and teams on Gogs.
.. Open a browser window, navigate to the Gogs server home page and log in with your username/password.
.. Create a new Organization and call it `process-server-jenkins`.
.. Add user `jenkins` to the `owner` team of the `process-server-jenkins` organization.
. Create a repository named `policyquote-process` in the `process-server-jenkins` organization on the Gogs server.
. On the virtual machine, make a new clone the Policyquote-process project and push to Gogs.
.. Open a terminal, change to the lab home folder and clone the Policyquote-process project from Github:
+
----
$ cd /home/jboss/lab
$ git clone https://github.com/gpe-mw-training/bxms-xpaas-policyquote-process policyquote-process
----
.. Add a remote repository to the cloned project pointing to the Gogs server:
+
----
$ cd policyquote-process
$ git remote add gogs http://<gogs username>:<gogs password>@<url of the gogs route>/process-server-jenkins/policyquote-process.git

----
+
Replace <gogs password>,<url of the gogs route> and <gogs username> with the appropriate values for your environment.
.. Push the code to the Gogs server:
+
----
$ git push gogs master
----

=== Jenkins Build server

The Jenkins build server has been set up in the previous lab. The Jenkins server has been pre-configured with two build jobs, `policyquote` and `policyquote-process`. In this lab we will use the `policyquote-process` build job.

image::images/jenkins-master-policyquote-process.png[]

. Click on the `policyquote-process` job, and then on `Configure`. +
Notice that the `policyquote-process` job uses a Pipeline, but has no Pipeline script defined yet. We will add the Pipeline script in the next steps of the lab. +
The `policyquote-process` is a parameterized build. It takes the branch name to build as a parameter, allowing to maker a distinction between builds of the master and release branch (only release branch builds will trigger a deployment on OpenShift).

=== Process Server deployment marker project

In this part of the Process Server lab, we use Jenkins to build the kjar, so there is no need to rebuild the same kjar on the Process Server, but we still need to tell the Process Server what needs to be deployed.

For this we can use a Git project that contains a properties file which has a property pointing to the release Id (maven group id, artifact id, version) of the kjars to be deployed. We will also add the files containing the users and roles to this project.

. On the lab virtual machine, open a browser window and navigate to the Gogs server on Openshift. Log in with your username/password.
. Create a repository named `policyquote-process-ocp` in the `process-server-jenkins` organization on the Gogs server.
. On the lab virtual machine, open a terminal and change to the lab home folder.
+
----
$ cd /home/jboss/lab
----
. Create the directories `policyquote-process-ocp/.s2i` and `policyquote-process/configuration`, and change to the `policyquote-process-ocp` directory.
+
----
$ mkdir -p policyquote-process-ocp/.s2i
$ mkdir -p policyquote-process-ocp/configuration
$ cd policyquote-process-ocp
----
. Create a file called `environment` in the `policyquote-process-ocp/.s2i` folder.
+
----
$ touch .s2i/environment
----
. Open the `environment` file for editing, and set the contents to:
+
----
KIE_CONTAINER_DEPLOYMENT_OVERRIDE=
----
+
The GAV (groupId, artifactId, version) of the kjar(s) and the KIE-container alias to be deployed will be appended to this line as part of the build job on Jenkins.
. Create a file called `application-users.properties` in the `configuration` directory.
+
----
$ touch configuration/application-users.properties
----
. Using a text editor, open the `configuration/application-users.properties` file. Paste the following contents in the file and save:
+
----
user1=e6e3515c498a9dd0d3f9ff109a563d70
user10=aab70ed7128574f33830762d5a7706b8
user11=d52988665526b974adda93cbd3af9657
user2=60a186310ff25f5eaf61371df513e9dd
user20=63b620eaa18caf1df6a29891a24f5338
user21=37e033fbd7f1398e9897b7bba355338b
----
. Create a file called `application-roles.properties` in the `configuration` directory.
+
----
$ touch configuration/application-roles.properties
----
. Using a text editor, open the `configuration/application-roles.properties` file. Paste the following contents in the file and save:
+
----
user1=kie-server,agent
user10=kie-server,agent
user11=kie-server,agent
user2=kie-server,reviewer
user21=kie-server,reviewer
user22=kie-server,reviewer
----
. Push the project to the Gogs server
+
----
$ git init
$ git remote add gogs http://<gogs username>:<gogs password>@<url of the gogs route>/process-server-jenkins/policyquote-process-ocp.git
$ git add --all
$ git commit -m "initial commit"
$ git push gogs master
----

=== Jenkins Build pipeline

Now we can add the Jenkins build pipeline script to the `policyquote-process` build job in Jenkins.

. Open a browser window and navigate to the Jenkins home page on OpenShift. Log in.
. Click on the `policyquote-process` job, and then click on `Configure`. Scroll down to the Pipeline definition section.
+
image::images/policyquote-pipeline.png[]
. In the Script pane, paste the following contents:
+
----
node('jdk8') {
  def mvnHome = tool 'M3'
  def mvnCmd = "${mvnHome}/bin/mvn -s ${env.JENKINS_HOME}/settings.xml -f policyquote-process/pom.xml"

  stage 'Build'
    git url: 'http://jenkins:password@gogs:3000/process-server-jenkins/policyquote-process.git', branch: "${branch}"
    def groupId = getGroupIdFromPom("policyquote-process/pom.xml")
    def artifactId = getArtifactIdFromPom("policyquote-process/pom.xml")
    def version = getVersionFromPom("policyquote-process/pom.xml")
    echo "Building branch ${branch} - version ${version}"
    sh "${mvnCmd} clean package -DskipTests=true"

  stage 'Test'
    try {
      sh "${mvnCmd} test"
    } catch (err) {
      step([$class: 'JUnitResultArchiver', testResults: '**/target/surefire-reports/TEST-*.xml'])
      throw err
    }

  if ("${branch}".startsWith("release")) {
    stage 'Publish'
      sh "${mvnCmd} deploy -DskipTests=true -DaltDeploymentRepository=nexus::default::http://nexus:8081/content/repositories/releases"

    stage 'Deploy to STAGING'
      git url: 'http://jenkins:password@gogs:3000/process-server-jenkins/policyquote-process-ocp.git'
      sh "sed -r -i \"s/^KIE_CONTAINER_DEPLOYMENT_OVERRIDE=(.*)[0-9]*\\.[0-9]*\\.[0-9]*\$/&|/\" .s2i/environment"
      sh "sed -r -i \"s/^KIE_CONTAINER_DEPLOYMENT_OVERRIDE=.*/&policyquote-process=${groupId}:${artifactId}:${version}/\" .s2i/environment"
      def commit = "Release " + version
      sh "git add .s2i/environment && git commit -m \"${commit}\" && git push origin master"
      //openshiftBuild bldCfg: 'policyquote', namespace: '<openshift project>'
  }

}

def getVersionFromPom(pom) {
  def matcher = readFile(pom) =~ '<version>(.+)</version>'
  matcher ? matcher[0][1] : null
 }

def getGroupIdFromPom(pom) {
  def matcher = readFile(pom) =~ '<groupId>(.+)</groupId>'
  matcher ? matcher[0][1] : null
 }

def getArtifactIdFromPom(pom) {
  def matcher = readFile(pom) =~ '<artifactId>(.+)</artifactId>'
  matcher ? matcher[0][1] : null
}
----
. The Jenkins pipeline consists of the following stages:
* All the stages will run on slave nodes labeled `jdk8`.
* The `Build` stage checks out the kjar source code project from Gogs. +
The GAV of the project is determined from the project POM file.
The project is built using maven. Test execution is skipped in this phase.
* In the `Test` stage, unit tests are executed (`mvn test`).
* If the project also has integration, performance or behaviour-driven test suites, they should be executed in their own stages following the test stage. Stages can be run in parallel to speed up build time.
* The `Publish` and `Deploy to Staging` phases are only executed if the branch being built is a release branch.
* In the `Publish` stage, the build artifact(s) are published to the Nexus repository (`mvn deploy`).
* In the `Deploy to Staging` stage, the marker project we created in the previous step is checked out. The GAV of the project is appended to the value of the `KIE_CONTAINER_DEPLOYMENT_OVERRIDE` with the `policyquote-process` container alias. The change is committed and pushed. +
Then a new build of the `policyquote` application on OpenShift is triggered using the `oc` client, which will replace the current Process Server application with a new one which contains a KIE-Container for each of the GAV's specified in `KIE_CONTAINER_DEPLOYMENT_OVERRIDE`. +
Note that the OpenShift build step is commented out, as the `policyquote` application has not been created yet.
. Save the script

=== Prepare for release and execute the first build

. On the virtual machine, change to the directory with the cloned `policyquote-process` project:
+
----
$ cd /home/jboss/lab/policyquote-process
----
. Create the `release` branch, checkout the branch and bump up the project version to `1.0.0`.
+
----
$ git branch release
$ git checkout release
$ mvn versions:set -f policyquote-process/pom.xml -DgenerateBackupPoms=false -DnewVersion=1.0.0
$ git add policyquote-process/pom.xml
$ git commit -m "release 1.0.0"
----
. Push the release branch to Gogs:
+
----
$ git push gogs release
----
. Bump the version of the master branch to `1.1-SNAPSHOT`.
+
----
$ git checkout master
$ mvn versions:set -f policyquote-process/pom.xml -DgenerateBackupPoms=false -DnewVersion=1.1-SNAPSHOT
$ git add policyquote-process/pom.xml
$ git commit -m "master version 1.1-SNAPSHOT"
----
. On the Jenkins server, execute the `policyquote-process` pipeline. Click `Build with Parameters` on the `policyquote-process` build job page. +
Specify `release` for the branch parameter. Click `Build`.
+
image::images/policyquote-process-pipeline-branch.png[]
.. Observe how the build is moving through the different stages.
+
image::images/policyquote-process-pipeline-build-2.png[]
.. The Jenkins build job is executed on a slave node, which runs on a dedicated pod, spawned for the duration of the build.
+
image::images/jenkins-slave-pod.png[]
.. The Nexus repository contains the `1.0.0` version of the policyquote-process kjar archive.
+
image::images/policyquote-process-kjar-nexus.png[]
.. The value of the `KIE_CONTAINER_DEPLOYMENT_OVERRIDE` property in the `.s2i/environment` file of the `policyquote-ocp` project is set to the value `policyquote-process=com.redhat.gpte.xpaas.process-server:policyquote-process:1.0.0`.
+
image::images/policyquote-process-deployment-override.png[]

=== Process Server Application

Now we can deploy the Process Server application for the policyquote-process kjar.

. In the virtual machine, open a terminal, change to the directory in the cloned lab project that contains the templates for the Process Server lab:
+
----
$ cd /home/jboss/lab/bxms-advanced-infrastructure-lab/xpaas/process-server
----
. Issue the following commands (replace expressions between `<>` with correct values for your environment) to create the application:
+
----
$ application_name=policyquote
$ source_repo=http://gogs:3000/process-server-jenkins/policyquote-process-ocp.git
$ nexus_url=http://nexus:8081
$ kieserver_password=kieserver1!
$ is_namespace=<name of your OpenShift project>
$ oc new-app --template=processserver63-mysql-persistent-s2i -p APPLICATION_NAME=$application_name,SOURCE_REPOSITORY_URL=$source_repo,KIE_SERVER_PASSWORD=$kieserver_password,IMAGE_STREAM_NAMESPACE=$is_namespace,KIE_CONTAINER_REDIRECT_ENABLED=true,MAVEN_MIRROR_URL=$nexus_url/content/groups/public/
----
. Once the deployment of the Process Server is finished, use curl to check the containers deployed. You should get the following response:
+
----
{
  "type": "SUCCESS",
  "msg": "List of created containers",
  "result": {
    "kie-containers": {
      "kie-container": [
        {
          "status": "STARTED",
          "messages": [
            {
              "severity": "INFO",
              "timestamp": 1477908565571,
              "content": [
                "Container 3a9d813a567dbc0c5c178f538d3be890 successfully created with module com.redhat.gpte.xpaas.process-server:policyquote-process:1.0.0."
              ]
            }
          ],
          "container-id": "3a9d813a567dbc0c5c178f538d3be890",
          "release-id": {
            "version": "1.0.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "resolved-release-id": {
            "version": "1.0.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "config-items": []
        }
      ]
    }
  }
}
----
+
Note that the KIE-Container name is a hexadecimal string. This is because of the value of the `KIE_CONTAINER_REDIRECT_ENABLED` parameter, which is set to `true`. From the client side however, we can use the container alias name (`policyquote-process`) as name for the KIE-Container in the REST API calls. The redirection mechanism will resolve the alias to the correct target KIE-Container.
. Using curl, create a couple of process instances. Use `policyquote-process` as KIE-Container name. +
Make sure you keep at least one process instance in a User task wait state before proceeding with the remainder of the lab.

=== Complete and automate the Jenkins build pipeline

To complete the pipeline, we can trigger a Jenkins build when code is committed into the policyquote-process source repository, and have the Jenkins build start a new build of the Process Server application at the end of the build pipeline.

. Open a browser, navigate to the Gogs server, log in, and go the `process-server-jenkins/policyquote-process` repository. Click on `Settings`, and then on `Git Hooks`.
. Click on the pencil icon next to `post-receive`.
. In the `Hook Content` text box, paste the following scriptlet:
+
----
#!/bin/bash

while read oldrev newrev refname
do
    branch=$(git rev-parse --symbolic --abbrev-ref $refname)
    if [[ "$branch" == "master" || "$branch" == release* ]]; then
    	curl -X POST --user admin:password http://jenkins:8080/job/policyquote-process/buildWithParameters?branch=${branch}&token=mysecret
    fi
done
----
+
This script will signal the Jenkins policyquote build job every time a commit is received in the master or release branch. +
Click `Update Hook`.
. Go to the Jenkins server page, select the `policyquote-jenkins` job, click `Configure`. +
In the pipeline script, uncomment the last line of the `Deploy to Staging` stage.
+
----
    stage 'Deploy to STAGING'
      git url: 'http://jenkins:password@gogs:3000/process-server-jenkins/policyquote-process-ocp.git'
      sh "sed -r -i \"s/^KIE_CONTAINER_DEPLOYMENT_OVERRIDE=(.*)[0-9]*\\.[0-9]*\\.[0-9]*\$/&|/\" .s2i/environment"
      sh "sed -r -i \"s/^KIE_CONTAINER_DEPLOYMENT_OVERRIDE=.*/&policyquote-process=${groupId}:${artifactId}:${version}/\" .s2i/environment"
      def commit = "Release " + version
      sh "git add .s2i/environment && git commit -m \"${commit}\" && git push origin master"
      openshiftBuild bldCfg: 'policyquote', namespace: '<openshift project>'
----
+
Replace <openshift project> with the name of your OpenShift project. +
Save the pipeline.

=== Release a new version of the Policyquote-process application.

We can now introduce a change in the Policyquote-process project, and trigger a new release of the application.

. On the virtual machine, change to the directory with the cloned `policyquote-process` project:
+
----
$ cd /home/jboss/lab/policyquote-process
----
. Check out the master branch.
+
----
$ git checkout master
----
. To simulate a change in the project, we will change the version of the process definition, and the log statement in the last node of the process instance using `sed`.
+
----
$ sed -i 's/drools:version="1.0"/drools:version="2.0"/' policyquote-process/src/main/resources/PolicyQuoteProcess.bpmn2
$ sed -i 's/Driver /Version 2 : Driver /' policyquote-process/src/main/resources/PolicyQuoteProcess.bpmn2
----
. Commit the changes to the master branch
+
----
$ git add policyquote-process/src/main/resources/PolicyQuoteProcess.bpmn2
$ git commit -m "PolicyQuoteProcess version 2"
----
. Cherry-pick the commit in the release branch.
.. Find the commit hash:
+
----
$ git log -n 1
----
+
----
commit 1cab08bf076f60acec878366ac9e13c343593281
Author: Bernard Tison <bernard.tison@gmail.com>
Date:   Mon Oct 31 12:16:18 2016 +0100

    PolicyQuoteProcess version 2
----
.. Checkout the release branch and cherry-pick the commit:
+
----
$ git checkout release
$ git cherry-pick 1cab08bf076f60acec878366ac9e13c343593281
----
+
Note: your commit hash value will be different.
.. Bump up the project version of the release branch to `1.1.0`:
+
----
$ mvn versions:set -f policyquote-process/pom.xml -DgenerateBackupPoms=false -DnewVersion=1.1.0
$ git add policyquote-process/pom.xml
$ git commit -m "release 1.1.0"
----
+
.. Push the release branch to Gogs:
+
----
$ git push gogs release
----
. The push to Gogs will trigger the post-receive hook, start a Jenkins build and finally trigger a new build and deployment of the Policyquote app on OpenShift.
+
image::images/policyquote-process-application-build.png[]
. A container definition for the version `1.1.0` of the kjar has been added to the `KIE_CONTAINER_REDIRECT_ENABLED` variable in the  `.s2i/environment` file of the `policyquote-ocp` project:
+
image::images/policyquote-process-deployment-override-2.png[]
. The Policyquote Process Server app has 2 containers deployed, resolving to the versions `1.0.0` and `1.1.0` of the kjar:
+
----
{
  "type": "SUCCESS",
  "msg": "List of created containers",
  "result": {
    "kie-containers": {
      "kie-container": [
        {
          "status": "STARTED",
          "messages": [
            {
              "severity": "INFO",
              "timestamp": 1477913467477,
              "content": [
                "Container 991b463bc066da010a051daf87ff581d successfully created with module com.redhat.gpte.xpaas.process
-server:policyquote-process:1.1.0."
              ]
            }
          ],
          "container-id": "991b463bc066da010a051daf87ff581d",
          "release-id": {
            "version": "1.1.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "resolved-release-id": {
            "version": "1.1.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "config-items": []
        },
        {
          "status": "STARTED",
          "messages": [
            {
              "severity": "INFO",
              "timestamp": 1477913468207,
              "content": [
                "Container 3a9d813a567dbc0c5c178f538d3be890 successfully created with module com.redhat.gpte.xpaas.process
-server:policyquote-process:1.0.0."
              ]
            }
          ],
          "container-id": "3a9d813a567dbc0c5c178f538d3be890",
          "release-id": {
            "version": "1.0.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "resolved-release-id": {
            "version": "1.0.0",
            "group-id": "com.redhat.gpte.xpaas.process-server",
            "artifact-id": "policyquote-process"
          },
          "config-items": []
        }
      ]
    }
  }
}
----
. Using curl, create a couple of process instances. Use `policyquote-process` as container name.
. Check that the processes are created in the container corresponding to the `1.1.0` KIE-Container. +
Note that you need to use the real container name here, not the alias.
+
----
$ curl -X GET -H "Accept: application/json" --user kieserver:$kieserver_password "$policyquote_app/kie-server/services/rest/server/queries/containers/991b463bc066da010a051daf87ff581d/process/instances"
----
+
Response:
+
----
{
  "process-instance": [
    {
      "initiator": "kieserver",
      "process-instance-id": 3,
      "process-id": "policyquote.PolicyQuoteProcess",
      "process-name": "PolicyQuoteProcess",
      "process-version": "2.0",
      "process-instance-state": 1,
      "container-id": "991b463bc066da010a051daf87ff581d",
      "start-date": 1477914603000,
      "process-instance-desc": "PolicyQuoteProcess",
      "correlation-key": "",
      "parent-instance-id": -1
    },
    {
      "initiator": "kieserver",
      "process-instance-id": 4,
      "process-id": "policyquote.PolicyQuoteProcess",
      "process-name": "PolicyQuoteProcess",
      "process-version": "2.0",
      "process-instance-state": 1,
      "container-id": "991b463bc066da010a051daf87ff581d",
      "start-date": 1477914611000,
      "process-instance-desc": "PolicyQuoteProcess",
      "correlation-key": "",
      "parent-instance-id": -1
    }
  ]
}
----
. Using curl, complete the process instances. Use `policyquote-process` as KIE-Container name. In the logs of the Process Server pod, you'll see something like:
+
----
12:48:41,122 INFO  [stdout] (http-172.17.0.7:8080-1) Version 2 : Driver 1234: Policy price after calculation and review = 300
----
. Also complete the process instances created with version `1.0.0`, still using `policyquote-process` as KIE-Container name. For those processes you'll see in the pod logs:
+
----
12:51:16,136 INFO  [stdout] (http-172.17.0.7:8080-1) Driver 1234: Policy price after calculation and review = 300
----
+
Processes are being executed in the container they were created in. This is transparent from the client perspective.

Before proceeding with the second part of the lab, tear down the `policyquote` application:

----
$ oc delete all -l "application=policyquote"
$ oc delete pvc policyquote-mysql-pvc
----

== xPaaS Process Server Lab 3 : Integration with RH SSO

In the previous labs, we had to add users and roles in properties files inside our project to be able to log in into the Process Server and interact with business process. This might be fine for a Proof-of-Concept, but is not an appropriate solution for a real life project.

The xPaaS Process Server Docker images are built on the xPaaS EAP images, which have built-in support for integration with Red Hat SSO. This allows applications deployed on the xPaaS EAP application server to use Red Hat SSO for user authentication and autorization. We can use the same mechanism to integrate the xPaaS Process Server with Red Hat SSO.

In this lab we will also use SSL for all communication with and between the Process Server and the SSO server.

=== Preparation of certificates, keystores and trustsores.

. On the lab virtual machine, create a directory `ssl` in the lab home folder. Change to the `ssl` directory:
+
----
$ mkdir ~/home/jboss/lab/ssl
$ cd ~/home/jboss/lab/ssl
----
. Generate a CA certificate.
+
----
$ openssl req -new -newkey rsa:4096 -x509 -keyout xpaas.key -out xpaas-ca.crt -days 365 -subj "/CN=xpaas-sso.ca"
----
+
Remember the key passphrase.
. Generate a certificate for the SSL keystore to be used on the SSO server:
+
----
$ keytool -genkeypair -keyalg RSA -keysize 2048 -dname "CN=rhsso-<name of your OpenShift project>.<name of your OpenShift domain>" -alias xpaas-https-key -keystore xpaas-sso-https.jks
----
+
Replace <name of your OpenShift project> and <name of your OpenShift domain> with the correct values for your environment.
+
Remember the keystore password. Choose the same password for the key.
. Generate a certificate for the SSL keystore to be used on the Process Server:
+
----
$ keytool -genkeypair -keyalg RSA -keysize 2048 -dname "CN=policyquote-<name of your OpenShift project>.<name of your OpenShift domain>" -alias xpaas-https-key -keystore xpaas-ps-https.jks
----
+
Remember the keystore password. Choose the same password for the key.
. Create Certificate Sign Requests for the keys in our keystores:
+
----
$ keytool -certreq -keyalg rsa -alias xpaas-https-key -keystore xpaas-sso-https.jks -file xpaas-sso.csr
$ keytool -certreq -keyalg rsa -alias xpaas-https-key -keystore xpaas-ps-https.jks -file xpaas-ps.csr
----
. Sign the Certificate Sign Requests with the CA certificate:
+
----
$ openssl x509 -req -CA xpaas-ca.crt -CAkey xpaas.key -in xpaas-sso.csr -out xpaas-sso.crt -days 365 -CAcreateserial
$ openssl x509 -req -CA xpaas-ca.crt -CAkey xpaas.key -in xpaas-ps.csr -out xpaas-ps.crt -days 365 -CAcreateserial
----
. Import the CA into the SSL keystores:
+
----
$ keytool -import -file xpaas-ca.crt -alias xpaas.ca -keystore xpaas-sso-https.jks
$ keytool -import -file xpaas-ca.crt -alias xpaas.ca -keystore xpaas-ps-https.jks
----
. Import the signed Certificate Sign Request into the SSL keystores:
+
----
$ keytool -import -file xpaas-sso.crt -alias xpaas-https-key -keystore xpaas-sso-https.jks
$ keytool -import -file xpaas-ps.crt -alias xpaas-https-key -keystore xpaas-ps-https.jks
----
. Import the CA in a truststore:
+
----
$ keytool -import -file xpaas-ca.crt -alias xpaas.ca -keystore truststore.jks
----

=== Red Hat SSO Server

The xPaaS collection of images for OpensShift includes an image for Red Hat SSO 7.0. An ImageStream for this image is installed by default in OpenShift.

The SSO image uses a secret to hold the keystore and truststore created in the previous chapter. Within these images the secret is mounted as a volume on the image file system, so that they can be used by the SSO server.

. Create a service account to hold the secret.
+
----
$ oc create serviceaccount sso-service-account
----
. Create the secret with the keystore and truststore.
+
----
$ oc create secret generic sso-app-secret --from-file=xpaas-sso-https.jks --from-file=truststore.jks
----
. Add the secret to the service account:
+
----
$ oc secret add sa/sso-service-account secret/sso-app-secret
----
. Change to the directory in the cloned lab project that contains the common templates for the xPaaS lab.
+
----
$ cd /home/jboss/lab/bxms-advanced-infrastructure-lab/xpaas/common
----
. Review the `xpaas-sso-mysql-persistent.yaml` template. This is a template for the installation of Red Hat SSO server, using MySQL as a database. +
The template defines:
* A Service for the Red Hat SSO server, bound to port 8443.
* A Route for the Red Hat SSO Server. The route is configured with TLS, and will be exposed using the HTTPS protocol.
* A DeploymentConfig for the Red Hat SSO server pod. The DeploymentConfig uses the `redhat-sso70-openshift` ImageStream. It is also configured to use the service-account created in the previous paragraph. Also note that the keystore and truststore are being mounted in `/etc/eap-secret-volume` and `/etc/sso-secret-volume`.
* A DeploymentConfig for the MySQL pod.
* A PersistentVolumeClaim for the MySQL data volume.
* Parameters:
** HTTPS_KEYSTORE: The name of the keystore file within the secret.
** HTTPS_PASSWORD: The password for the keystore.
** SSO_TRUSTSTORE: The name of the truststore file within the secret.
** SSO_TRUSTSTORE_PASSWORD: The password for the truststore.
+
For the other parameters we can use the default or generated values.
. Create an application based on the template:
+
----
$ https_keystore=xpaas-sso-https.jks
$ https_password=<keystore password>
$ sso_truststore=truststore.jks
$ sso_truststore_password=<truststore password>
$ oc process -f xpaas-sso-mysql-persistent.yaml -v HTTPS_KEYSTORE=$https_keystore,HTTPS_PASSWORD=$https_password,SSO_TRUSTSTORE=$sso_truststore,SSO_TRUSTSTORE_PASSWORD=$sso_truststore_password | oc create -f -
----
. Once all components are up, you should see the Red Hat SSO application in the OpenShift console.
+
image::images/ocp-sso-application.png[]
+
Note that the `rhsso` route is exposed over HTTPS.
. Open a web browser, and navigate to <URL of the rhsso route>/auth/admin. Login with `admin/admin`. +
Your browser will warn you that the connection is unsafe. This is expected as our SSL certificate has not been signed by a trusted CA.
. Create a new Realm. On the home page, hover over the `Master` realm, and click on the `Add realm` button to create a new realm.
+
image::images/rh-sso-new-realm.png[]
. In the `Add Realm` pane, click on `Select file`, and select the `processserver-realm.json` file in the `xpaas/common/export` directory of the lab project. Click `Create`. +
This creates the realm, a client for curl, as well as a number of roles that can be used for the Policyquote-process application.
. In the `Processserver` realm pane, click on `Import`. Select the `processserver-users-0.json` file in the `xpaas/common/export` directory of the lab project and click `Import` to import user definitions. +
All users have the password `user`.
. Create a `openid-connect` client for the Process Server. +
In the `Processserver` realm pane, select `Clients`, and click the `Create` button.
. Name the client `process-server`, and make sure the protocol is set to `openid-connect`. Leave the other fields blank. Click `Save`.
. On the `Settings` page of the `process-server` client, select `bearer-only` for the Access type. Click `Save`.
. Test that the realm is working correctly with curl:
+
----
$ rhsso_url=<URL of the RH SSO server>
$ cacert=<path to the xpaas-ca.crt certificate file>
$ TKN=$(curl -X POST "$rhsso_url/auth/realms/processserver/protocol/openid-connect/token" \
 -H "Content-Type: application/x-www-form-urlencoded" \
 -d "username=user1" \
 -d "password=user" \
 -d "grant_type=password" \
 -d "client_id=curl" \
  --cacert $cacert \
| sed 's/.*access_token":"//g' | sed 's/".*//g')
$ echo $TKN
----
+
You should obtain an encoded token:
+
----
$ echo $TKN
eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiIyNWIwYjc1MS0yNGQxLTQ2MmUtYjBlMy0yYmYyZjc0YmM3ZWIiLCJleHAiOjE0NzgzNzA4MzAsIm5iZiI6MCwiaWF0IjoxNDc4MzcwNTMwLCJpc3MiOiJodHRwczovL3Joc3NvLXhwYWFzLm9wZW5zaGlmdC5jZGsudm0vYXV0aC9yZWFsbXMvcHJvY2Vzc3NlcnZlciIsImF1ZCI6ImN1cmwiLCJzdWIiOiI4NDUxZjk0MC0yYjgzLTQ3YjMtYWM3ZC04ZjQwMGUwMDE1OTciLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJjdXJsIiwic2Vzc2lvbl9zdGF0ZSI6IjliYzUzZjViLTQ0NDUtNDE0OS04MGEyLTgxY2ZiYTJjNDljNyIsImNsaWVudF9zZXNzaW9uIjoiY2JjNmEyZDgtMDk2MC00ZjQ1LWE2ZTctNzU2M2E1ODI1ODBlIiwiYWxsb3dlZC1vcmlnaW5zIjpbXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImFnZW50Iiwia2llLXNlcnZlciIsImdyb3VwMSJdfSwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJ2aWV3LXByb2ZpbGUiXX19LCJuYW1lIjoiIiwicHJlZmVycmVkX3VzZXJuYW1lIjoidXNlcjEifQ.Lpo3ztry9C6Zz4XLMRmZzMzYOWa0Mvh2FOFSgze1RWnb_GaK02qpHD2stcoehFOysERbPi2kC0RVGT1sAhQNa8FeLXd4gOjxeasrlyP8WlvcVkCJaBE2bdXOi_juQMqVEAymFgsDEI9JciJvuOsB8lWM8pdPan5JnrxWSi4b0-TTsUt4gibDjFZGO0eUbHeEbRFvSnYZeGp2CpzjB60r3k3xjAi5umTiUih8KSjZWfWOHbp7BFrcFT6gFpqI2aznEpPhWAh8Jiedj1ZbRamqW8BE6mja-cOywx-5taY9vD7vbWuW42HCgmQbilbZ8SHMlG2yhpJO7joSX4CRSsxWrw
----

=== Process Server deployment project

. Open a browser window and navigate to the Gogs server on OpenShift. Login with your username and password.
. Create an organization `process-server-sso`. Create a repository `policyquote-process-sso-ocp` in the `process-server-sso` organization.
. On the lab virtual machine, open a terminal and change to the lab home folder.
+
----
$ cd /home/jboss/lab
----
. Create a directory `policyquote-process-sso-ocp`. Change to this directory.
+
----
$ mkdir policyquote-process-sso-ocp
$ cd policyquote-process-sso-ocp
----
. Create a directory `.s2i`, and create a file `environment` within that directory.
+
----
$ mkdir .s2i
$ touch .s2i/environment
----
. Open the `environment` file for editing, and set the content to:
+
----
KIE_CONTAINER_DEPLOYMENT_OVERRIDE=policyquote-process=com.redhat.gpte.xpaas.process-server:policyquote-process:1.0.0
----
+
This tells the Process Server to deploy the `1.0.0` version of the policyquote-process project into a KIE-container with alias `policyquote-process`. The kjar should already be published in the Nexus repository as part of the previous lab.
+
Save the file.
. To configure the Process Server to use Red Hat SSO for authentication, we need to copy the Red Hat SSO client adapter configuration to a file called `secure-deployments`. +
During the S2I build, the contents of this file will be merged into the Process Server configuration file.
.. In the `policyquote-process-sso-ocp` project, create a directory `configuration`, and in that directory create a file called `secure-deployments`.
+
----
$ mkdir configuration
$ touch configuration/secure-deployments
----
.. Open the `secure-deployments` file for editing.
.. In a browser window, go to the Red Hat SSO server, and navigate to the `process-server` client page of the `Processserver` realm. +
Click on `Installation`, and select the `Keycloak OIDC JBOss Subsystem XML` format.
+
image::images/rh-sso-client-installation.png[]
.. Copy the XML fragment and copy into the `secure-deployments` file.
.. Change the `WAR MODULE NAME.war` value of the `secure-deployments` tag to `kie-server.war`.
.. Add configuration for CORS, the principal attribute and the truststore. The `secure-deployments` file should look like:
+
----
<secure-deployment name="kie-server.war">
    <realm>processserver</realm>
    <realm-public-key>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAhAxGFraO+K+5qbpdlEJLG5LppyHtgMLc6EA3+VDrDDAiN0XFr+f4PTiK0Ijv1VrHC61NaVcdQsUilOk2xlV/8z2IZrmutZfPv/vkORfxVhytogykYn8+KbOPVg4KLutbqDdB4HaW2CD9UcBZg4DjzXke6sl9yu/yZVm9Ja07IL2LKsGXKqEPrm/0AlZjUCngn6VDbYEyS4AFtB2PsptQPix427aCqp8VlVo2tkcUCQFNgzYFve95rIks1WieBn+20SIESx2WqclZg2enOy4/4n4Pw+6oNIEuVePaj83dwnc1tgUoE8YtP0AMUfIoqq/CwJaf7pkqls1rxZe2YyahqQIDAQAB</realm-public-key>
    <auth-server-url>https://rhsso-xpaas.openshift.cdk.vm/auth</auth-server-url>
    <bearer-only>true</bearer-only>
    <ssl-required>ALL</ssl-required>
    <resource>process-server</resource>
    <enable-cors>true</enable-cors>
    <cors-max-age>1000</cors-max-age>
    <cors-allowed-methods>POST, PUT, DELETE, GET</cors-allowed-methods>
    <principal-attribute>preferred_username</principal-attribute>
    <disable-trust-manager>false</disable-trust-manager>
    <truststore>/etc/processserver-secret-volume/truststore.jks</truststore>
    <truststore-password>password</truststore-password>
</secure-deployment>
----
+
Note that your value for `auth-server-url` and `truststore-password` will be different.
.. Save the `secure-deployments` file.
. Finally, we need a way to change the authentication method as defined in the `web.xml` descriptor of the `kie-server.war` deployment of the Process Server. This value needs to change from `BASIC` to `KEYCLOAK` for the Process Server to use SSO authenticaton. +
In the current version of the Process Server image, we cannot achieve this by configuration, so we need to override the S2I script that launches the Process Server.
.. In the `policyquote-process-sso-ocp` project, create the directory `.s2i/bin`, and in that directory create a file `run`.
+
----
$ mkdir .s2i/bin
$ touch .s2i/bin/run
----
.. Open the `.s2i/bin/run` for editing, and set the contents to:
+
----
#!/bin/sh

sed -i "s'<auth-method>.*</auth-method>'<auth-method>KEYCLOAK</auth-method>'g" $JBOSS_HOME/standalone/deployments/kie-server.war/WEB-INF/web.xml

exec $JBOSS_HOME/bin/kieserver-launch.sh
----
+
This script uses `sed` to change the value of the authentication method in the `web.xml` of the `kie-server.war` deployment. It then launches the Process Server start script.
.. Save the file
. At this point, the structure of the `policyquote-process-sso-ocp` project should look like:
+
image::images/policyquote-process-sso-ocp.png[]
. Push the `policyquote-process-sso-ocp` to the Gogs server:
+
----
$ git init
$ git remote add gogs http://<gogs username>:<gogs password>@<url of the gogs route>/process-server-sso/policyquote-process-sso-ocp.git
$ git add --all
$ git commit -m "initial commit"
$ git push gogs master
----

=== Process Server application

Now we are ready to deploy the Process Server application.

. Create a service account the hold the secret with the keystore and truststore for SSL:
+
----
$ oc create serviceaccount processserver-service-account
----
+
. Create the secret with the keystore and truststore. Navigate to the directory where you created the keystore and truststore files.
+
----
$ oc create secret generic processserver-app-secret --from-file=xpaas-ps-https.jks --from-file=truststore.jks
----
. Add the secret to the service account:
+
----
$ oc secret add sa/processserver-service-account secret/processserver-app-secret
----
. Change to the directory in the cloned lab project that contains the templates for the Process Server lab:
+
----
$ cd /home/jboss/lab/bxms-advanced-infrastructure-lab/xpaas/process-server
----
. Review the `processserver-sso-mysql-persistent-s2i.yaml` template. +
This template is similar to the Process Server application template we used previously, except that it is configured to use HTTPS as transport protocol.
. Issue the following commands (replace expressions between <> with correct values for your environment) to create the application:
+
----
$ application_name=policyquote
$ source_repo=http://gogs:3000/process-server-sso/policyquote-process-sso-ocp.git
$ is_namespace=<name of your OpenShift project>
$ nexus_url=http://nexus:8081
$ https_keystore=xpaas-ps-https.jks
$ https_name=xpaas-https-key
$ https_password=<keystore password>
$ oc process -f processserver-sso-mysql-persistent-s2i.yaml -v APPLICATION_NAME=$application_name,SOURCE_REPOSITORY_URL=$source_repo,IMAGE_STREAM_NAMESPACE=$is_namespace,MAVEN_MIRROR_URL=$nexus_url/content/groups/public/,HTTPS_KEYSTORE=$https_keystore,HTTPS_NAME=$https_name,HTTPS_PASSWORD=$https_password | oc create -f -
----
. Once all components are up, you should see the Policyquote application in the OpenShift console.
+
image::images/ocp-policyquote-application.png[]
+
Note that the `policyquote` route is exposed over HTTPS.
. We can use curl to test the application. Before issuing a curl command against the Process Server, a token must be obtained from the Red Hat SSO Server, and that token must be passed to the Process Server. +
To obtain a token, as `user1`:
+
----
$ rhsso_url=<URL of the RH SSO server>
$ cacert=<path to the xpaas-ca.crt certificate file>
$ TKN=$(curl -X POST "$rhsso_url/auth/realms/processserver/protocol/openid-connect/token" \
 -H "Content-Type: application/x-www-form-urlencoded" \
 -d "username=user1" \
 -d "password=user" \
 -d "grant_type=password" \
 -d "client_id=curl" \
  --cacert $cacert \
| sed 's/.*access_token":"//g' | sed 's/".*//g')
----
. To check which KIE-Containers are deployed on the server:
+
----
$ policyquote_url=<URL of the Process Server>
$ curl -X GET -H "Accept: application/json" -H "Authorization: Bearer $TKN" --cacert $cacert "$policyquote_url/kie-server/services/rest/server/containers"
----
+
Note that basic authentication (using `--user user1:user` instead of `-H "Authorization: Bearer $TKN"` in the curl request) does not longer work, and returns a HTTP 401 code.
. Using the curl commands from the first chapter of the lab, you can test the policyquote-process. +
For example to start a new process:
+
----
curl -X POST -H "Accept: application/json" -H "Content-Type: application/json" -H "Authorization: Bearer $TKN" --cacert $cacert -d @policyquote-start-process-payload.json "$policyquote_url/kie-server/services/rest/server/containers/policyquote-process/processes/policyquote.PolicyQuoteProcess/instances"
----
+
Remember to get a new token when you want to switch users. Change the username in the curl token request accordingly. Tokens have a limited lifespan. You will have to request a new token if the current one is expired.


ifdef::showscript[]
endif::showscript[]
